use super::ast::{self, Expr, Pattern};

grammar(ctx: &mut crate::ParseCtx);

Comment = r"#.*";

Ident: String = <r"(?:\p{XID_Start}|_)\p{XID_Continue}*"> => String::from(<>);
IntLiteral: String = {
    <r"-?(?:0|[1-9]\d*)"> => String::from(<>),
};
FloatLiteral: String =
    <r"-?(?:0|[1-9]\d*)\.\d*(?:[eE][+-]?\d+)?"> => String::from(<>);

VarOrLit: Expr = {
    <l: @L> <x:Ident> <r: @R> => match x.as_str() {
        "false" | "true" => ctx.expr_literal(ast::LiteralKind::Bool, x, (l, r)),
        _ => ctx.expr_var(x, (l, r))
    },
    <l: @L> <x:FloatLiteral> <r: @R> => ctx.expr_literal(ast::LiteralKind::Float, x, (l, r)),
    <l: @L> <x:IntLiteral> <r: @R> => ctx.expr_literal(ast::LiteralKind::Int, x, (l, r)),
};

Term: Expr = {
    <VarOrLit> Comment*,
    "(" Comment* <Expr> ")" Comment*,
};

Expr: Expr = {
    // 0. basic term
    #[precedence(level="0")]
    <Term>,
    // 1. call
    #[precedence(level="1")] #[assoc(side="left")]
    <l: @L> <a:Expr> <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Call, a, b, (l, r))
    },
    // 2. unary ops
    #[precedence(level="2")]
    <l: @L> "!" Comment* <x:Expr> <r: @R> => {
        ctx.unary(ast::UnOp::Not, x, (l, r))
    },
    // 3. pow
    #[precedence(level="3")] #[assoc(side="right")]
    <l: @L> <a:Expr> "**" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Pow, a, b, (l, r))
    },
    // 4. mul/div
    #[precedence(level="4")] #[assoc(side="left")]
    <l: @L> <a:Expr> "*" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Mul, a, b, (l, r))
    },
    #[precedence(level="4")] #[assoc(side="left")]
    <l: @L> <a:Expr> "/" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Div, a, b, (l, r))
    },
    #[precedence(level="4")] #[assoc(side="left")]
    <l: @L> <a:Expr> "//" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::FloorDiv, a, b, (l, r))
    },
    #[precedence(level="4")] #[assoc(side="left")]
    <l: @L> <a:Expr> "%" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Rem, a, b, (l, r))
    },
    // 5. add/sub
    #[precedence(level="5")] #[assoc(side="left")]
    <l: @L> <a:Expr> "+" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Add, a, b, (l, r))
    },
    #[precedence(level="5")] #[assoc(side="left")]
    <l: @L> <a:Expr> "-" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Sub, a, b, (l, r))
    },
    // 6. shl/shr
    #[precedence(level="6")] #[assoc(side="left")]
    <l: @L> <a:Expr> "<<" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Shl, a, b, (l, r))
    },
    #[precedence(level="6")] #[assoc(side="left")]
    <l: @L> <a:Expr> ">>" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Shr, a, b, (l, r))
    },
    // 7. bit and
    #[precedence(level="7")] #[assoc(side="left")]
    <l: @L> <a:Expr> "&" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::BitAnd, a, b, (l, r))
    },
    // 8. bit xor
    #[precedence(level="8")] #[assoc(side="left")]
    <l: @L> <a:Expr> "^" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::BitXor, a, b, (l, r))
    },
    // 9. bit or
    #[precedence(level="9")] #[assoc(side="left")]
    <l: @L> <a:Expr> "|" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::BitOr, a, b, (l, r))
    },
    // 10. cmp
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> "==" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Eq, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> "!=" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Ne, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> "<" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Lt, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> ">" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Gt, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> "<=" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Le, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> ">=" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Ge, a, b, (l, r))
    },
    // 11. and
    #[precedence(level="11")] #[assoc(side="left")]
    <l: @L> <a:Expr> "&&" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::And, a, b, (l, r))
    },
    // 12. or
    #[precedence(level="12")] #[assoc(side="left")]
    <l: @L> <a:Expr> "||" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Or, a, b, (l, r))
    },
    // 13. lambda
    #[precedence(level="13")] #[assoc(side="right")]
    <l: @L> <a:Pattern> "=>" Comment* <b:Expr> <r: @R> => {
        ctx.lambda(a, b, (l, r))
    },
    // 14. let
    #[precedence(level="14")] #[assoc(side="right")]
    <l: @L> "let" Comment* <a:Pattern> "=" Comment* <b:Expr> ";" Comment* <c:Expr> <r: @R> => {
        ctx.letrec(a, b, c, (l, r))
    },
};

Pattern: Pattern = {
    <l: @L> <x:Ident> <r: @R> => ctx.pattern_var(x, (l, r)),
};

TopLevelDecl: ast::Tld = {
    <l: @L> <pat:Pattern> "=" Comment* <body:Expr> ";" <r: @R> Comment* => {
    	ctx.tld(pat, body, (l, r))
    }
};

pub Script = {
   Comment* <TopLevelDecl*>
}
