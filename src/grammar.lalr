use super::{Wrapper, ast::{self, Ident, Expr, LetArm, Pattern}};

grammar(ctx: &mut crate::ParseCtx);

Comment = r"#.*";

Ident: Ident = <r"(?:\p{XID_Start}|_)\p{XID_Continue}*"> => String::from(<>);
IntLiteral: String = {
    <r"-?(?:0|[1-9]\d*)"> => String::from(<>),
};
FloatLiteral: String =
    <r"-?(?:0|[1-9]\d*)\.\d*(?:[eE][+-]?\d+)?"> => String::from(<>);

VarOrLit: Expr = {
    <l: @L> <x:Ident> <r: @R> => match x.as_str() {
        "false" | "true" => ctx.expr_literal(ast::LiteralKind::Bool, x, (l, r)),
        _ => ctx.expr_var(x, (l, r))
    },
    <l: @L> <x:FloatLiteral> <r: @R> => ctx.expr_literal(ast::LiteralKind::Float, x, (l, r)),
    <l: @L> <x:IntLiteral> <r: @R> => ctx.expr_literal(ast::LiteralKind::Int, x, (l, r)),
};

Term: Expr = {
    <VarOrLit> Comment*,
    "(" Comment* <Expr> ")" Comment*,
};

Expr: Expr = {
    // 0. basic term
    #[precedence(level="0")]
    <Term>,
    // 1. call
    #[precedence(level="1")] #[assoc(side="left")]
    <l: @L> <a:Expr> <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Call, a, b, (l, r))
    },
    // 2. unary ops
    #[precedence(level="2")]
    <l: @L> "!" Comment* <x:Expr> <r: @R> => {
        ctx.unary(ast::UnOp::Not, x, (l, r))
    },
    // 3. pow
    #[precedence(level="3")] #[assoc(side="right")]
    <l: @L> <a:Expr> "**" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Pow, a, b, (l, r))
    },
    // 4. mul/div
    #[precedence(level="4")] #[assoc(side="left")]
    <l: @L> <a:Expr> "*" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Mul, a, b, (l, r))
    },
    #[precedence(level="4")] #[assoc(side="left")]
    <l: @L> <a:Expr> "/" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Div, a, b, (l, r))
    },
    #[precedence(level="4")] #[assoc(side="left")]
    <l: @L> <a:Expr> "//" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::FloorDiv, a, b, (l, r))
    },
    #[precedence(level="4")] #[assoc(side="left")]
    <l: @L> <a:Expr> "%" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Rem, a, b, (l, r))
    },
    // 5. add/sub
    #[precedence(level="5")] #[assoc(side="left")]
    <l: @L> <a:Expr> "+" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Add, a, b, (l, r))
    },
    #[precedence(level="5")] #[assoc(side="left")]
    <l: @L> <a:Expr> "-" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Sub, a, b, (l, r))
    },
    // 6. shl/shr
    #[precedence(level="6")] #[assoc(side="left")]
    <l: @L> <a:Expr> "<<" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Shl, a, b, (l, r))
    },
    #[precedence(level="6")] #[assoc(side="left")]
    <l: @L> <a:Expr> ">>" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Shr, a, b, (l, r))
    },
    // 7. bit and
    #[precedence(level="7")] #[assoc(side="left")]
    <l: @L> <a:Expr> "&" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::BitAnd, a, b, (l, r))
    },
    // 8. bit xor
    #[precedence(level="8")] #[assoc(side="left")]
    <l: @L> <a:Expr> "^" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::BitXor, a, b, (l, r))
    },
    // 9. bit or
    #[precedence(level="9")] #[assoc(side="left")]
    <l: @L> <a:Expr> "|" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::BitOr, a, b, (l, r))
    },
    // 10. cmp
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> "==" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Eq, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> "!=" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Ne, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> "<" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Lt, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> ">" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Gt, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> "<=" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Le, a, b, (l, r))
    },
    #[precedence(level="10")] #[assoc(side="none")]
    <l: @L> <a:Expr> ">=" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Ge, a, b, (l, r))
    },
    // 11. and
    #[precedence(level="11")] #[assoc(side="left")]
    <l: @L> <a:Expr> "&&" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::And, a, b, (l, r))
    },
    // 12. or
    #[precedence(level="12")] #[assoc(side="left")]
    <l: @L> <a:Expr> "||" Comment* <b:Expr> <r: @R> => {
        ctx.binary(ast::BinOp::Or, a, b, (l, r))
    },
    // 13. lambda
    #[precedence(level="13")] #[assoc(side="right")]
    <l: @L> "fun" Comment* <a:Pattern> "=>" Comment* <b:Expr> <r: @R> => {
        ctx.lambda(a, b, (l, r))
    },
    // 14. let
    #[precedence(level="14")] #[assoc(side="right")]
    <l: @L> "let" Comment* <arms:LetBindingArm+> "in" Comment* <body:Expr> <r: @R> => {
        ctx.letrec(arms, body, (l, r))
    },
};

LetBindingArm: LetArm = {
    <l: @L> <x:Ident> <r0: @R> Comment* "=" Comment* <b:Expr> ";" <r: @R> Comment* => {
        let p = ctx.let_pattern_var(x, (l, r));
        ctx.let_arm(p, b, (l, r))
    },
    <l: @L> <x:Ident> Comment* <args:BasicPattern+> <r0: @R> "=>" Comment* <b:Expr> ";" <r: @R> Comment* => {
        let p = ctx.let_pattern_func(x, args, (l, r0));
        ctx.let_arm(p, b, (l, r))
    },
    <l: @L> "type" Comment* <l1: @L> <x:Ident> <r1: @R> Comment* ";" <r: @R> Comment* => {
        let (p, b) = ctx.let_pattern_type(x, (l1, r1));
        ctx.let_arm(p, b, (l, r))
    }
};

BasicPattern: Pattern = {
    "(" Comment* <p:Pattern> ")" Comment* => p,
    <l: @L> <x:Ident> <r: @R> Comment* => ctx.pattern_var(x, (l, r)),
};
IdentCommentSpan: (Ident, (usize, usize)) = {
    <l: @L> <x:Ident> <r: @R> Comment* => (x, (l, r)),
};
Pattern: Pattern = {
    <l: @L> <t:IdentCommentSpan*> <x:BasicPattern> <r: @R> => ctx.pattern_tagged(Wrapper(t), x, (l, r)),
};

TopLevelDecl: ast::Tld = {
    <b:LetBindingArm> => {
        ctx.tld(b)
    }
};

pub Script = {
   Comment* <TopLevelDecl*>
}
