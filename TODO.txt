optimizations (use HashSets and intern type constraints)
this is hard to do with diagnostics, but the groundwork is done
that is, i will have to throw away graphviz debug output but error diagnostics will be kept

(to do it, just change TypeCk::{pos,neg} to be OrderedSets, this will ensure most types stay compact-ish)

for best performance, figure out how to ensure ConstraintGraph::constraints hashes ids semantically
(maybe split ids into "shape id" and "type id", and use OrderedMap<ShapeId, TypeId>?)



- only retain new query generations in flows for optimization

- allow matching on multiple patterns
^this requires checking whether pos can *sometimes* be used in neg, not whether it *always* can be used in neg.
how to do it? well, a potential solution is creating a separate query for every new inflow.
Sounds slow, but what else can you realistically do here?
^if match patterns are kept small (if cuts are well placed), this won't be super bad actually
^this isn't actually enough since this can only resolve top-level "choices", but sub-typevars may also come from multiple
 sources. Instead, I suppose a proper solution needs to do subsumption checks, this is like a flipped version of the normal
 biunification algo (in the normal algo, we fail on any conflict, but here we must succeed on any success, but pass through
 any failures to the next branch)
^all in all this is important to implement for refutable patterns
